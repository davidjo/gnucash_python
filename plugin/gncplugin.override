%%
headers
#include <Python.h>

#include "config.h"

#include "stdio.h"

#include "pygobject.h"

#include "gobject/gobject.h"

#include "glib.h"

#include "gtk/gtk.h"

//#include "qof.h"
#include "gnc-plugin.h"

%%
modulename gncplugin
%%
import gobject.GObject as PyGObject_Type
import gtk.UIManager as PyGtkUIManager_Type
import gtk.ActionGroup as PyGtkActionGroup_Type
%%
ignore-glob
  *_get_type
%%
body

int dbgflg = 0;

static PyObject *
makePyObjectFromPrintf(const char *fmt, ...)
{
    PyObject *rv = NULL;
    char msg[2048];
    int slen = 0;
    va_list args;

    memset(msg, 0, sizeof(msg));
    va_start(args, fmt);
    slen = vsnprintf(msg, sizeof(msg), fmt, args);
    va_end(args);

    if (slen > 0)
        rv = PyString_FromStringAndSize(msg, slen);

    return rv;
}


// ;; the following functions are defined in gnc-plugin.h but do not use the
// ;; gnc-plugin class/instance structs in any way
// ;; these are essentially global functions
// ;; define as a function for this module

%%
override gnc_plugin_init_short_names kwargs

static PyObject *
_wrap_gnc_plugin_init_short_names(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "action_group", "toolbar_labels", NULL };
    PyObject *action_group_obj;
    GtkActionGroup *action_group;
    PyObject *toolbar_labels_obj;
    action_toolbar_labels *toolbar_labels;
    int indx_toolbar_labels;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO:GncPluginPage.init_short_names",
                                     kwlist, &action_group_obj, &toolbar_labels_obj)) {
        return NULL;
    }

    if (pygobject_check(action_group_obj, &PyGtkActionGroup_Type)) {
        action_group = GTK_ACTION_GROUP(pygobject_get(action_group_obj));
    } else {
        PyErr_SetString(PyExc_TypeError,
                        "action_group must be a GtkActionGroup");
        return NULL;
    }

    if (!PyList_Check(toolbar_labels_obj)) {
        PyErr_SetString(PyExc_TypeError, "toolbar_labels argument is not a list");
        return NULL;
    }
    int nitms = PyList_Size(toolbar_labels_obj);
    toolbar_labels = (action_toolbar_labels *) g_malloc(sizeof(action_toolbar_labels)*(nitms+1));
    for (indx_toolbar_labels=0; indx_toolbar_labels<nitms; indx_toolbar_labels++)
        {
        PyObject *ptupl = PyList_GetItem(toolbar_labels_obj,indx_toolbar_labels);
        if (!PyTuple_Check(ptupl)) {
            PyErr_SetString(PyExc_TypeError, "toolbar_labels list item is not a tuple");
            return NULL;
        }
        PyObject *pitm1 = PyTuple_GetItem(ptupl,0);
        if (!PyString_Check(pitm1)) {
            PyErr_SetString(PyExc_TypeError, "toolbar_labels list item action_name is not a string");
            return NULL;
        }
        PyObject *pitm2 = PyTuple_GetItem(ptupl,1);
        if (!PyString_Check(pitm2)) {
            PyErr_SetString(PyExc_TypeError, "toolbar_labels list item label is not a string");
            return NULL;
        }
        toolbar_labels[indx_toolbar_labels].action_name = PyString_AsString(pitm1);
        toolbar_labels[indx_toolbar_labels].label = PyString_AsString(pitm2);
        }
    toolbar_labels[nitms].action_name = NULL;
    toolbar_labels[nitms].label = NULL;

    // hmm - this does not check if the action names in toolbar_labels
    // actually exists in the action_group
    gnc_plugin_init_short_names (action_group, toolbar_labels);

    // Im assuming gnc_plugin_init_short_names takes a copy of the names
    g_free(toolbar_labels);
    
    Py_INCREF(Py_None);
    return Py_None;
}


%%
override gnc_plugin_access_private_data
static PyObject *
_wrap_gnc_plugin_access_private_data(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    PyObject *class_obj;

    GncPlugin *page = (GncPlugin *)self->obj;
    GncPluginClass *klass = GNC_PLUGIN_GET_CLASS(page);

    if (dbgflg) fprintf(stderr,"access plugin class is %llx\n",(unsigned long long) klass);

    //klass->tab_icon    = NULL;
    //klass->plugin_name = NULL;

    /* pyg_pointer_new handles NULL checking */
    class_obj = pyg_pointer_new(G_TYPE_POINTER,klass);

    return class_obj;

}

%%
override gnc_plugin_set_class_init_data kwargs

//  the following are necesssary as I can see no way to set the private class data
//  of a C code GObject subtype in python - except by providing some access functions

static PyObject *
_wrap_gnc_plugin_set_class_init_data(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "plugin_name", "actions_name", "actions", "toggle_actions", "important_actions", "ui_filename", NULL };
    PyObject *plugin_name_obj = NULL;
    PyObject *actions_name_obj = NULL;
    PyObject *actions_obj = NULL;
    PyObject *toggle_actions_obj = NULL;
    PyObject *important_actions_obj = NULL;
    PyObject *ui_filename_obj = NULL;

    GncPlugin *page = (GncPlugin *)self->obj;
    GncPluginClass *klass = GNC_PLUGIN_GET_CLASS(page);

    // hmm - for me looks like do NOT use GIL state in functions called from python!!

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO|OOOO:GncPlugin.set_class_init_data",
                                     kwlist, &plugin_name_obj, &actions_name_obj, &actions_obj, &toggle_actions_obj, &important_actions_obj, &ui_filename_obj)) {
        return NULL;
    }

    fprintf(stderr,"plugin_name pointer %llx\n",(void *)plugin_name_obj);
    fprintf(stderr,"actions_name pointer %llx\n",(void *)actions_name_obj);

    char *pname = PyString_AsString(plugin_name_obj);
    fprintf(stderr,"pname pointer %llx\n",(void *)pname);
    if (pname != NULL)
        klass->plugin_name = pname;  // gchar *

    char *aname = PyString_AsString(actions_name_obj);
    fprintf(stderr,"aname pointer %llx\n",(void *)aname);
    if (aname != NULL)
        klass->actions_name = aname;  // gchar *

    // we need to convert the python data here and store into the
    // class data structures because these are used by the
    // primary functions gnc_plugin_add_to_window and gnc_plugin_remove_from_window
    // these functions do not simply just call a subclass definition
    // - they do that at the end

    //klass->actions = NULL; // GtkActionEntry *
    //klass->n_actions = 0; // guint 
    //klass->toggle_actions = NULL; // GtkToggleActionEntry *
    //klass->n_toggle_actions = 0; // guint
    //klass->important_actions = NULL; // gchar **
    //klass->ui_filname = NULL; // gchar *

    Py_INCREF(Py_None);
    return Py_None;
}

// this is complicated - in C the actions for a plugin subclass are generally a static
// definition
// so somehow we have to convert a python equivalent structure into a c structure
// in a piece of memory thats not going to disappear!!
// as the python wrapping object should exist for same period as GObject version
// we should be able to use the character pointers without copying

// more thinking - we dont need to do this if we re-implement the base gnc_plugin_add_to_window etc
// in python - because these class variable contents will be NULL which means the base
// gnc_plugin_add_to_window wont do anything - but it will call the subclass add_to_window callback


GtkActionEntry *
gnc_plugin_convert_actions(PyObject *action_entry_list)
{
    int itm;

    int n_actions = PyList_Size(action_entry_list);
    GtkActionEntry *gnc_python_actions = (GtkActionEntry *) g_malloc(sizeof(gchar *)*(n_actions));

    // we have to re-write the actions

    for (itm = 0; itm < n_actions; itm++)
        {
        char *pstr1,*pstr2,*pstr3,*pstr4,*pstr5;
        PyObject *pobj6;
        GtkActionEntry *tmpgtkact = &gnc_python_actions[itm];

        // NOTE the test for Py_None if string object is None
        // actually maybe should make ""  the NULL string??

        PyObject *ptupl = PyList_GetItem(action_entry_list,itm);
        if (!PyTuple_Check(ptupl)) {
            PyErr_SetString(PyExc_TypeError, "action list entry is not a tuple");
            return NULL;
        }
        int tupl_size = PyTuple_Size(ptupl);
        if (tupl_size < 1 || tupl_size > 6) {
            return NULL;
        }
        PyObject *pitm1 = PyTuple_GetItem(ptupl,0);
        pstr1 = NULL;
        if (pitm1 != Py_None)
            pstr1 = PyString_AsString(pitm1);
        pstr2 = NULL;
        if (tupl_size > 1) {
            PyObject *pitm2 = PyTuple_GetItem(ptupl,1);
            if (pitm2 != Py_None)
                pstr2 = PyString_AsString(pitm2);
        }
        pstr3 = NULL;
        if (tupl_size > 2) {
            PyObject *pitm3 = PyTuple_GetItem(ptupl,2);
            if (pitm3 != Py_None)
                pstr3 = PyString_AsString(pitm3);
        }
        pstr4 = NULL;
        if (tupl_size > 3) {
            PyObject *pitm4 = PyTuple_GetItem(ptupl,3);
            if (pitm4 != Py_None)
                pstr4 = PyString_AsString(pitm4);
        }
        pstr5 = NULL;
        if (tupl_size > 4) {
            PyObject *pitm5 = PyTuple_GetItem(ptupl,4);
            if (pitm5 != Py_None)
                pstr5 = PyString_AsString(pitm5);
        }
        if (tupl_size > 5) {
            pobj6 = PyTuple_GetItem(ptupl,5);
            Py_INCREF(Py_None);
            pobj6 = Py_None;
        }
        if (PyErr_Occurred())
            {
            fprintf(stderr,"Python Error in convert actions 2\n");
            //PyErr_Print();
            return NULL;
            }

        // pobj6 is a callback

        // and re-save action entry with generic C callback
        // still not sure if I need to copy the strings here
        tmpgtkact->name = (gchar *)pstr1;
        tmpgtkact->stock_id = (gchar *)pstr2;
        tmpgtkact->label = (gchar *)pstr3;
        tmpgtkact->accelerator = (gchar *)pstr4;
        tmpgtkact->tooltip = (gchar *)pstr5;
        // this is not right!!
        // if (pobj6 != Py_None)
        //     tmpgtkact->callback = G_CALLBACK(gnc_python_callback);
        // else
        //     tmpgtkact->callback = NULL;
        }

    // always do this check at end of any routine using Python calls
    // to clear any python error that may have occurred
    // - otherwise will be reported at some later time!!
    if (PyErr_Occurred())
        {
        fprintf(stderr,"Python Error in callback add_actions setup\n");
        //PyErr_Print();
        return NULL;
        }

    return gnc_python_actions;
}


%%
override gnc_plugin_set_callbacks kwargs

void
gnc_plugin_generic_add_to_window(GncPlugin *plugin, GncMainWindow *window, GQuark type);
void
gnc_plugin_generic_remove_from_window(GncPlugin *plugin, GncMainWindow *window, GQuark type);

static PyObject *
_wrap_gnc_plugin_set_callbacks(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    //static char *kwlist[] = { "callbacks", NULL };
    PyObject *callb_obj = NULL;

    GncPlugin *page = (GncPlugin *)self->obj;
    GncPluginClass *gnc_plugin_class = GNC_PLUGIN_GET_CLASS(page);

    // hmm - for me looks like do NOT use GIL state in functions called from python!!

    //if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GncPlugin.set_callbacks",
    //                                 kwlist, &callb_obj)) {
    //    return NULL;
    //}

    if (dbgflg) fprintf(stderr,"callback plugin class is %llx\n",(unsigned long long) gnc_plugin_class);

    //klass->tab_icon    = NULL;
    //klass->plugin_name = NULL;

    // I think these will be null if not defined - which looks like is tested for in superclass
    // yes - this is defined in gnc-plugin-page.c

    // looks like we need them all defined - make it so

    if (!PyObject_HasAttrString((PyObject*)self,"add_to_window")) {
        fprintf(stderr,"no add_to_window callback!!\n");
        PyErr_SetString(PyExc_KeyError, "no add_to_window callback");
        return NULL;
    }
    if (!PyObject_HasAttrString((PyObject*)self,"remove_from_window")) {
        fprintf(stderr,"no remove_from_window callback!!\n");
        PyErr_SetString(PyExc_KeyError, "no remove_from_window callback");
        return NULL;
    }

    // these are instance callbacks -  in that the first argument is an instance pointer
    // bit confusing as they are effectively defined in the class
    // so might think they are class methods in python
    // Im still confused - is there only one instance of the class structure in GType system
    // I think there is - and I think it is defined once the type is registered
    // but note that subclasses get a separate copy of the parent class structure
    gnc_plugin_class->add_to_window   = gnc_plugin_generic_add_to_window;
    gnc_plugin_class->remove_from_window   = gnc_plugin_generic_remove_from_window;

    if (dbgflg) fprintf(stderr,"callback plugin class end\n");

    Py_INCREF(Py_None);
    return Py_None;
}

    /** A callback that will be invoked when this plugin is added
     *  to a window.  This allows the plugin to perform any
     *  special actions at insertion time.
     *
     *  @param user_data A pointer to the this GncPlugin data
     *  structure.
     *
     *  @param window A pointer to the window in which this plugin
     *  has just been installed.
     *
     *  @param type An identifier for the type of window
     *  specified.  Currently the only type is a "main" content
     *  window. */

void
gnc_plugin_generic_add_to_window(GncPlugin *plugin, GncMainWindow *window, GQuark type)
{
    PyGILState_STATE gstate;
    GQuark quark;
    PyObject *pyobj;

    // this works beautifully!!
    // we get the python object from the GObject
    quark = g_quark_from_string("PyGObject::wrapper");
    pyobj = g_object_get_qdata((GObject *)plugin, quark);

    gstate = PyGILState_Ensure();

    PyObject *pywindow = pygobject_new((GObject*)window);

    gchar *typestr = g_quark_to_string(type);
    PyObject *pytype = PyString_FromString(typestr);

    PyObject_CallMethodObjArgs(pyobj,PyString_FromString("add_to_window"),pywindow,pytype,NULL);
    if (PyErr_Occurred())
        {
        fprintf(stderr,"Python Error in add_to_window\n");
        PyErr_Print();
        }

    PyGILState_Release(gstate);
}

    /** A callback that will be invoked when this plugin is
     *  removed from a window.  This allows the plugin to perform
     *  any special actions at removal time.
     *
     *  @param user_data A pointer to the this GncPlugin data
     *  structure.
     *
     *  @param window A pointer to the window from which this
     *  plugin is about to be removed.
     *
     *  @param type An identifier for the type of window
     *  specified.  Currently the only type is a "main" content
     *  window. */

void
gnc_plugin_generic_remove_from_window(GncPlugin *plugin, GncMainWindow *window, GQuark type)
{
    PyGILState_STATE gstate;
    GQuark quark;
    PyObject *pyobj;

    // this works beautifully!!
    // we get the python object from the GObject
    quark = g_quark_from_string("PyGObject::wrapper");
    pyobj = g_object_get_qdata((GObject *)plugin, quark);

    gstate = PyGILState_Ensure();

    PyObject *pywindow = pygobject_new((GObject*)window);

    gchar *typestr = g_quark_to_string(type);
    PyObject *pytype = PyString_FromString(typestr);

    PyObject_CallMethodObjArgs(pyobj,PyString_FromString("remove_from_window"),pywindow,pytype,NULL);
    if (PyErr_Occurred())
        {
        fprintf(stderr,"Python Error in add_to_window\n");
        PyErr_Print();
        }

    PyGILState_Release(gstate);
}

%%
override gnc_plugin_set_callback kwargs

// new attempt at setting callbacks
// all available callbacks defined as keywords
// but value of keyword is immaterial as only self object is used ie only presence of keyword is significant
// essentially this allows for some callbacks to be not used
// not sure if this helps

static PyObject *
_wrap_gnc_plugin_set_callback(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "add_to_window", "remove_from_window", NULL };
    PyObject *add_to_window_obj = NULL;
    PyObject *remove_from_window_obj = NULL;

    GncPlugin *plugin = (GncPlugin *)self->obj;
    GncPluginClass *gnc_plugin_class = GNC_PLUGIN_GET_CLASS(plugin);

    // hmm - for me looks like do NOT use GIL state in functions called from python!!

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O:GncPlugin.set_callback",
                                     kwlist, &add_to_window_obj, &remove_from_window_obj)) {
        return NULL;
    }

    if (dbgflg) fprintf(stderr,"callback plugin class is %llx\n",(unsigned long long) gnc_plugin_class);

    if (add_to_window_obj != NULL) {
        if (!PyObject_HasAttrString((PyObject*)self,"add_to_window")) {
            fprintf(stderr,"no add_to_window callback!!\n");
            PyErr_SetString(PyExc_KeyError, "no add_to_window callback");
            return NULL;
        }
        gnc_plugin_class->add_to_window   = gnc_plugin_generic_add_to_window;
    }

    if (remove_from_window_obj != NULL) {
        if (!PyObject_HasAttrString((PyObject*)self,"remove_from_window")) {
            fprintf(stderr,"no remove_from_window callback!!\n");
            PyErr_SetString(PyExc_KeyError, "no remove_from_window callback");
            return NULL;
        }
        gnc_plugin_class->remove_from_window   = gnc_plugin_generic_remove_from_window;
    }

    Py_INCREF(Py_None);
    return Py_None;
}

