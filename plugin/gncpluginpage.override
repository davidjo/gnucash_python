%%
headers
#include <Python.h>

#include "config.h"

#include "stdio.h"

#include "pygobject.h"

#include "gobject/gobject.h"

//#include "glib.h"

#include "gtk/gtk.h"

#include "qof.h"
#include "gnc-plugin-page.h"

#include "pygkeyfile.h"

%%
modulename gncpluginpage
%%
import gobject.GObject as PyGObject_Type
import gtk.UIManager as PyGtkUIManager_Type
import gtk.Widget as PyGtkWidget_Type
import pygkeyfile.GKeyFile as PyGKeyFile_Type
%%
ignore-glob
  *_get_type
%%
body

QofBook *gnc_get_current_book();

%%
override gnc_plugin_page_recreate_page kwargs
// assuming python type self object here
// this ought to be a class method but dont see to do this
// making it a module level function currently
// note this is unlikely to ever be called from python
static PyObject *
_wrap_gnc_plugin_page_recreate_page(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "window", "page_type", "key_file", "page_group", NULL };
    PyObject *window_obj;
    GtkWidget *window;
    const gchar *page_type;
    PyObject *key_file_obj;
    GKeyFile *key_file = NULL;
    const gchar *page_group;
    GncPluginPage *pageret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OsOs:GncPluginPage.recreate_page",
                                     kwlist, &window_obj, &page_type, &key_file_obj, &page_group)) {
        return NULL;
    }

    if (pygobject_check(window_obj, &PyGtkWidget_Type))
        window = GTK_WIDGET(pygobject_get(window_obj));
    else if (window_obj != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "window must be a GtkWidget or None");
        return NULL;
    }

    // just to make my life complicated we dont have an easy GKeyFile python binding!!
    // GKeyFile is not a GObject object either
    if (key_file_obj != Py_None)
        {
        if (! PyObject_TypeCheck(key_file_obj, &PyGKeyFile_Type)) {
            PyErr_SetString(PyExc_TypeError, "key_file must be a GKeyFile object");
            return NULL;
        }
        key_file = ((PyGKeyFile *) key_file_obj)->key_file;
        }
    else
        {
        PyErr_SetString(PyExc_TypeError, "key_file must not be None but a GKeyFile object");
        return NULL;
        }

    pageret = gnc_plugin_page_recreate_page(window, page_type, key_file, page_group);

    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)pageret);
}

%%
override gnc_plugin_page_save_page kwargs
static PyObject *
_wrap_gnc_plugin_page_save_page(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "key_file", "group_name", NULL };
    PyObject *key_file_obj;
    GKeyFile *key_file = NULL;
    const gchar *group_name;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OsOs:GncPluginPage.save_page",
                                     kwlist, &key_file_obj, &group_name)) {
        return NULL;
    }

    // just to make my life complicated we dont have an easy GKeyFile python binding!!
    // GKeyFile is not a GObject object either
    if (key_file_obj != Py_None)
        {
        if (! PyObject_TypeCheck(key_file_obj, &PyGKeyFile_Type)) {
            PyErr_SetString(PyExc_TypeError, "key_file must be a GKeyFile object");
            return NULL;
        }
        // whats a good way to access this??
        key_file = ((PyGKeyFile *) key_file_obj)->key_file;
        }
    else
        {
        PyErr_SetString(PyExc_TypeError, "key_file must not be None but a GKeyFile object");
        return NULL;
        }

    gnc_plugin_page_save_page(GNC_PLUGIN_PAGE(self->obj), key_file, group_name);

    Py_INCREF(Py_None);
    return Py_None;
}

%%
override gnc_plugin_page_add_book kwargs
static PyObject *
_wrap_gnc_plugin_page_add_book(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "book", NULL };
    PyObject *book_obj;
    QofBook *book;

    QofBook *curbok = gnc_get_current_book ();
    fprintf(stderr,"add_book book %llx\n",(unsigned long long)curbok);

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GncPluginPage.add_book",
                                     kwlist, &book_obj)) {
        //if (PyErr_Occurred())
        //    PyErr_Print();
        return NULL;
    }
    fprintf(stderr,"add_book 1\n");

    // how to deal with book 
    // for the moment allow either integer or PyCObject
    if (book_obj != Py_None)
        {
        if (PyInt_Check(book_obj)) {
            book = (QofBook *) PyInt_AsUnsignedLongLongMask(book_obj);
        } else if (PyLong_Check(book_obj)) {
            book = (QofBook *) PyLong_AsUnsignedLongLong(book_obj);
        } else if (PyCObject_Check(book_obj)) {
            book = (QofBook *) PyCObject_AsVoidPtr(book_obj);
        } else {
            PyErr_SetString(PyExc_TypeError, "book must be a book object");
            return NULL;
        }
        }
    else
        {
        PyErr_SetString(PyExc_TypeError, "book must be a book object");
        return NULL;
        }
    fprintf(stderr,"add_book 2\n");

    gnc_plugin_page_add_book (GNC_PLUGIN_PAGE(self->obj), book);

    fprintf(stderr,"add_book 3\n");

    Py_INCREF(Py_None);
    return Py_None;
}


%%
override gnc_plugin_page_has_book kwargs
static PyObject *
_wrap_gnc_plugin_page_has_book(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "book", NULL };
    PyObject *book_obj;
    QofBook *book;
    gboolean hasret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GncPluginPage.has_book",
                                     kwlist, &book_obj)) {
        return NULL;
    }

    // how to deal with book 
    // for the moment assuming passed as PyCObject - will worry about how to generate this later
    if (book_obj != Py_None)
        {
        if (PyInt_Check(book_obj)) {
            book = (QofBook *) PyInt_AsUnsignedLongLongMask(book_obj);
        } else if (PyLong_Check(book_obj)) {
            book = (QofBook *) PyLong_AsUnsignedLongLong(book_obj);
        } else if (PyCObject_Check(book_obj)) {
            book = (QofBook *) PyCObject_AsVoidPtr(book_obj);
        } else {
            PyErr_SetString(PyExc_TypeError, "book must be a book object");
            return NULL;
        }
        }
    else
        {
        PyErr_SetString(PyExc_TypeError, "book must be a book object");
        return NULL;
        }

    hasret = gnc_plugin_page_has_book (GNC_PLUGIN_PAGE(self->obj), book);

    if (hasret)
        {
        Py_INCREF(Py_True);
        return Py_True;
        }
    else
        {
        Py_INCREF(Py_False);
        return Py_False;
        }
}

%%
override gnc_plugin_page_access_private_data
static PyObject *
_wrap_gnc_plugin_page_access_private_data(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    PyObject *class_obj;

    GncPluginPage *page = (GncPluginPage *)self->obj;
    GncPluginPageClass *klass = GNC_PLUGIN_PAGE_GET_CLASS(page);

    fprintf(stderr,"access plugin class is %llx\n",(unsigned long long) klass);

    //klass->tab_icon    = NULL;
    //klass->plugin_name = NULL;

    /* pyg_pointer_new handles NULL checking */
    class_obj = pyg_pointer_new(G_TYPE_POINTER,klass);

    return class_obj;

}

%%
override gnc_plugin_page_set_class_init_data kwargs

//  the following are necesssary as I can see no way to set the private class data
//  of a C code GObject subtype in python - except by providing some access functions
// here I need to set the page_name without calling the set_page_name function

static PyObject *
_wrap_gnc_plugin_page_set_class_init_data(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "plugin_name", "tab_icon", NULL };
    PyObject *plugin_name_obj = NULL;

    GncPluginPage *page = (GncPluginPage *)self->obj;
    GncPluginPageClass *klass = GNC_PLUGIN_PAGE_GET_CLASS(page);

    // hmm - for me looks like do NOT use GIL state in functions called from python!!

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|O:GncPluginPage.set_class_init_data",
                                     kwlist, &plugin_name_obj)) {
        return NULL;
    }

    char *pname = PyString_AsString(plugin_name_obj);

    //klass->tab_icon    = NULL;
    klass->plugin_name = pname;

    Py_INCREF(Py_None);
    return Py_None;
}

%%
override gnc_plugin_page_set_callbacks kwargs

GtkWidget *
gnc_plugin_page_report_generic_create_widget(GncPluginPage *plugin_page);
static void
gnc_plugin_page_report_generic_destroy_widget(GncPluginPage *plugin_page);
static void
gnc_plugin_page_report_generic_save_page(GncPluginPage *page, GKeyFile *file, const gchar *group);
static GncPluginPage *
gnc_plugin_page_report_generic_recreate_page(GtkWidget *window, GKeyFile *file, const gchar *group);
static void
gnc_plugin_page_report_generic_window_changed(GncPluginPage *plugin_page, GtkWidget *window);
static void
gnc_plugin_page_report_generic_page_name_changed(GncPluginPage *plugin_page, const gchar *name);
static void
gnc_plugin_page_report_generic_page_update_edit_menu_actions(GncPluginPage *plugin_page, gboolean hide);
static gboolean
gnc_plugin_page_report_generic_page_finish_pending(GncPluginPage *plugin_page);


static PyObject *
_wrap_gnc_plugin_page_set_callbacks(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    //static char *kwlist[] = { "callbacks", NULL };
    PyObject *callb_obj = NULL;

    GncPluginPage *page = (GncPluginPage *)self->obj;
    GncPluginPageClass *gnc_plugin_page_class = GNC_PLUGIN_PAGE_GET_CLASS(page);

    // do NOT use GIL state in functions called from python!!

    //if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GncPluginPage.set_callbacks",
    //                                 kwlist, &callb_obj)) {
    //    return NULL;
    //}

    fprintf(stderr,"callback plugin class is %llx\n",(unsigned long long) gnc_plugin_page_class);

    //klass->tab_icon    = NULL;
    //klass->plugin_name = NULL;

    // I think these will be null if not defined - which looks like is tested for in superclass
    // yes - this is defined in gnc-plugin-page.c

    // looks like we need them all defined - make it so

    if (!PyObject_HasAttrString((PyObject*)self,"create_widget")) {
        fprintf(stderr,"no create_widget callback!!\n");
        PyErr_SetString(PyExc_KeyError, "no create_widget callback");
        return NULL;
    }
    if (!PyObject_HasAttrString((PyObject*)self,"destroy_widget")) {
        fprintf(stderr,"no destroy_widget callback!!\n");
        PyErr_SetString(PyExc_KeyError, "no destroy_widget callback");
        return NULL;
    }
    if (!PyObject_HasAttrString((PyObject*)self,"save_page")) {
        fprintf(stderr,"no save_page callback!!\n");
        PyErr_SetString(PyExc_KeyError, "no save_page callback");
        return NULL;
    }
    //if (!PyObject_HasAttrString((PyObject*)self,"window_changed")) {
    //    fprintf(stderr,"no window_changed callback!!\n");
    //    PyErr_SetString(PyExc_KeyError, "no window_changed callback");
    //    return NULL;
    //}
    if (!PyObject_HasAttrString((PyObject*)self,"page_name_changed")) {
        fprintf(stderr,"no page_name_changed callback!!\n");
        PyErr_SetString(PyExc_KeyError, "no page_name_changed callback");
        return NULL;
    }
    if (!PyObject_HasAttrString((PyObject*)self,"update_edit_menu_actions")) {
        fprintf(stderr,"no update_edit_menu_actions callback!!\n");
        PyErr_SetString(PyExc_KeyError, "no update_edit_menu_actions callback");
        return NULL;
    }
    if (!PyObject_HasAttrString((PyObject*)self,"finish_pending")) {
        fprintf(stderr,"no finish_pending callback!!\n");
        PyErr_SetString(PyExc_KeyError, "no finish_pending callback");
        return NULL;
    }

    // these are the instance callbacks
    gnc_plugin_page_class->finish_pending   = gnc_plugin_page_report_generic_page_finish_pending;
    gnc_plugin_page_class->create_widget   = gnc_plugin_page_report_generic_create_widget;
    gnc_plugin_page_class->destroy_widget  = gnc_plugin_page_report_generic_destroy_widget;
    gnc_plugin_page_class->save_page       = gnc_plugin_page_report_generic_save_page;
    //gnc_plugin_page_class->window_changed   = gnc_plugin_page_report_generic_window_changed;
    gnc_plugin_page_class->page_name_changed = gnc_plugin_page_report_generic_page_name_changed;
    gnc_plugin_page_class->update_edit_menu_actions = gnc_plugin_page_report_generic_page_update_edit_menu_actions;

    // this is a creation callback
    // which Ive still not figured out
    // we need to figure the type of report somehow
    // we are NOT in the gncpluginpage module - this is a python subclass of it

    // we do not set this from a gncpluginpage instance
    //PyObject *moddict = PyImport_GetModuleDict();
    //if (!PyObject_HasAttrString(moddict,"gncpluginpage")) {
    //    PyErr_SetString(PyExc_KeyError, "the gncpluginpage module is not imported - impossible!!");
    //    return NULL;
    //}

    gnc_plugin_page_class->recreate_page   = gnc_plugin_page_report_generic_recreate_page;

    fprintf(stderr,"callback plugin class end\n");

    Py_INCREF(Py_None);
    return Py_None;
}

    /** Function called to create the display widget for a
     *  particular type of plugin.  The returned widget should
     *  encompass all information that goes with this page,
     *  including scroll bars, a summary bar, etc.
     *
     *  @param plugin_page A pointer to the plugin for which a
     *  display widget should be created.
     *
     *  @return A displayable gtk widget. */
GtkWidget *
gnc_plugin_page_report_generic_create_widget(GncPluginPage *plugin_page)
{
    PyGILState_STATE gstate;
    PyObject *PyRet;
    GtkWidget *widget = NULL;

    fprintf(stderr,"C create widget call\n");

    GQuark quark;
    PyObject *pyobj;

    // this works beautifully!!
    // we get the python object from the GObject
    quark = g_quark_from_string("PyGObject::wrapper");
    pyobj = g_object_get_qdata((GObject *)plugin_page, quark);

    fprintf(stderr,"quark wrapper is %llx\n",(void *)pyobj);

    if (PyObject_HasAttrString(pyobj,"create_widget"))
        fprintf(stderr,"pyobj has attr\n");
    else
        fprintf(stderr,"pyobj does not have attr\n");

    PyGILState_Ensure();

    PyRet = PyObject_CallMethod(pyobj,"create_widget",NULL);
    if (PyErr_Occurred())
        {
        fprintf(stderr,"Python Error in create_widget\n");
        PyErr_Print();
        PyGILState_Release(gstate);
        // what we might do is construct a minimal GtkWidget and return that
        // NULL gives bad things
        return NULL;
        }

    // need to figure how to get widget from this
    // ah - this this might work
    // may need to extract underlying GObject object
    widget = (GtkWidget *)PyObject_Hash(PyRet);

    PyGILState_Release(gstate);

    return widget;
}

    /** Function called to destroy the display widget for a
     *  particular type of plugin.
     *
     *  @param plugin_page A pointer to the plugin whose display
     *  widget should be destroyed. */
static void
gnc_plugin_page_report_generic_destroy_widget(GncPluginPage *plugin_page)
{
    PyGILState_STATE gstate;

    GQuark quark;
    PyObject *pyobj;

    // this works beautifully!!
    // we get the python object from the GObject
    quark = g_quark_from_string("PyGObject::wrapper");
    pyobj = g_object_get_qdata((GObject *)plugin_page, quark);

    PyGILState_Ensure();
    PyObject_CallMethod(pyobj,"destroy_widget",NULL);
    if (PyErr_Occurred())
        {
        fprintf(stderr,"Python Error in destroy_widget\n");
        PyErr_Print();
        }
    PyGILState_Release(gstate);
}

    /** Save enough information about this page so that it can be
     *  recreated next time the user starts gnucash.
     *
     *  @param page The page to save.
     *
     *  @param key_file A pointer to the GKeyFile data structure where the
     *  page information should be written.
     *
     *  @param group_name The group name to use when writing data.
     *  The name is specific to this page instance. */

static void
gnc_plugin_page_report_generic_save_page(GncPluginPage *page, GKeyFile *file, const gchar *group)
{
    PyGILState_STATE gstate;

    GQuark quark;
    PyObject *pyobj;

    // this works beautifully!!
    // we get the python object from the GObject
    quark = g_quark_from_string("PyGObject::wrapper");
    pyobj = g_object_get_qdata((GObject *)page, quark);

    PyGILState_Ensure();
    PyObject_CallMethod(pyobj,"save_page",NULL);
    if (PyErr_Occurred())
        {
        fprintf(stderr,"Python Error in save_page\n");
        PyErr_Print();
        }
    PyGILState_Release(gstate);
}

    /** Create a new page based on the information saved during a
     *  previous instantiation of gnucash.  This function may or
     *  may not install the new page in the window as it sees fit.
     *  Generally the function will install the page int the
     *  window in order to manipulate the menu items that are
     *  created at install time.
     *
     *  @param window The window where this new page will be
     *  installed.
     *
     *  @param key_file A pointer to the GKeyFile data structure where the
     *  page information should be retrieved.
     *
     *  @param group_name The group name to use when retrieving
     *  data.  The name is specific to this page instance.
     *
     *  @return A pointer to the new page. */

static GncPluginPage *
gnc_plugin_page_report_generic_recreate_page(GtkWidget *window, GKeyFile *file, const gchar *group)
{
    PyGILState_STATE gstate;
    PyObject *PyRet;
    GncPluginPage *page = NULL;

    // we need to figure out how to get page from here
    // MAJOR fixup needed
    fprintf(stderr,"recreate_page called - will fail!!!\n");

    PyGILState_Ensure();

    // we need to make this a module function or class method
    // this is still wrong 
    // we are NOT in the gncpluginpage module - this is a python subclass of it

    //PyObject *moddict = PyImport_GetModuleDict();
    //if (!PyObject_HasAttrString(moddict,"gncpluginpage")) {
    //    PyErr_SetString(PyExc_KeyError, "the gncpluginpage module is not imported - impossible!!");
    //    return NULL;
    //}
    //PyObject *modobj = PyDict_GetItemString(moddict,"gncpluginpage");
    PyObject *modobj = NULL;

    PyRet = PyObject_CallMethod(modobj,"gnc_plugin_page_recreate_page",NULL);
    if (PyErr_Occurred())
        {
        fprintf(stderr,"Python Error in gnc_plugin_page_recreate_page\n");
        PyErr_Print();
        PyGILState_Release(gstate);
        return NULL;
        }

    // need to figure how to get widget from this
    // ah - this this might work
    // may need to extract underlying GObject object
    page = (GncPluginPage *)PyObject_Hash(PyRet);

    PyGILState_Release(gstate);

    return page;
    
}

    /** Perform plugin specific actions when a page is added to a
     *  window (or has been removed from one window and added to a
     *  new window).  This function is called after the page is
     *  installed in the window, just before the window's
     *  PAGE_ADDED signal is generated.
     *
     *  @param page The page that was added to a window.
     *
     *  @param window The window where the page was added. */
static void
gnc_plugin_page_report_generic_window_changed(GncPluginPage *plugin_page, GtkWidget *window)
{
    PyGILState_STATE gstate;
    GQuark quark;
    PyObject *pyobj;

    // this works beautifully!!
    // we get the python object from the GObject
    quark = g_quark_from_string("PyGObject::wrapper");
    pyobj = g_object_get_qdata((GObject *)plugin_page, quark);

    PyGILState_Ensure();
    PyObject_CallMethod(pyobj,"window_changed",NULL);
    if (PyErr_Occurred())
        {
        fprintf(stderr,"Python Error in window_changed\n");
        PyErr_Print();
        }
    PyGILState_Release(gstate);
}

    /** This function vector allows page specific actions to occur
     *  when the page name is changed.
     *
     *  @param page The page to update.
     *
     *  @param name The new name for this page. */
static void
gnc_plugin_page_report_generic_page_name_changed(GncPluginPage *plugin_page, const gchar *name)
{
    PyGILState_STATE gstate;
    GQuark quark;
    PyObject *pyobj;

    // this works beautifully!!
    // we get the python object from the GObject
    quark = g_quark_from_string("PyGObject::wrapper");
    pyobj = g_object_get_qdata((GObject *)plugin_page, quark);

    PyGILState_Ensure();
    PyObject_CallMethod(pyobj,"page_name_changed",NULL);
    if (PyErr_Occurred())
        {
        fprintf(stderr,"Python Error in save_page\n");
        PyErr_Print();
        }
    PyGILState_Release(gstate);
}

    /** This function vector allows page specific actions to
     *  override the generic code for setting the sensitivity of
     *  items in the Edit menu.
     *
     *  @param page The front page in a main window..
     *
     *  @param hide Whether the widgets should be shown or
     *  hidden. */
static void
gnc_plugin_page_report_generic_page_update_edit_menu_actions(GncPluginPage *plugin_page, gboolean hide)
{
    PyGILState_STATE gstate;
    GQuark quark;
    PyObject *pyobj;

    // this works beautifully!!
    // we get the python object from the GObject
    quark = g_quark_from_string("PyGObject::wrapper");
    pyobj = g_object_get_qdata((GObject *)plugin_page, quark);

    PyGILState_Ensure();
    PyObject_CallMethod(pyobj,"update_edit_menu_actions",NULL);
    if (PyErr_Occurred())
        {
        fprintf(stderr,"Python Error in update_edit_menu_actions\n");
        PyErr_Print();
        }
    PyGILState_Release(gstate);
}

    /** This function vector is called to finish any outstanding
     *  activities.  It will be called for such things as closing a
     *  page, saving the data file, etc.
     *
     *  @param page The page in a main window.
     *
     *  @return FALSE if the page could not or would not comply,
     *  which should cancel the pending operation.  TRUE
     *  otherwise */
static gboolean
gnc_plugin_page_report_generic_page_finish_pending(GncPluginPage *plugin_page)
{
    PyGILState_STATE gstate;
    PyObject *PyRet = Py_None;
    GQuark quark;
    PyObject *pyobj;

    // this works beautifully!!
    // we get the python object from the GObject
    quark = g_quark_from_string("PyGObject::wrapper");
    pyobj = g_object_get_qdata((GObject *)plugin_page, quark);

    PyGILState_Ensure();
    PyRet = PyObject_CallMethod(pyobj,"finish_pending",NULL);
    if (PyErr_Occurred())
        {
        fprintf(stderr,"Python Error in finish_pending\n");
        PyErr_Print();
        }
    PyGILState_Release(gstate);
    
    if (PyRet == Py_True)
        return 1;
    else
        return 0;
}


