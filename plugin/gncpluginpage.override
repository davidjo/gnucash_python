%%
headers
#include <Python.h>

#include "config.h"

#include "stdio.h"

#include "pygobject.h"

#include "gobject/gobject.h"

//#include "glib.h"

#include "gtk/gtk.h"

#include "qof.h"
#include "gnc-plugin.h"
#include "gnc-plugin-page.h"

#include "pygkeyfile.h"

%%
modulename gncpluginpage
%%
import gobject.GObject as PyGObject_Type
import gtk.UIManager as PyGtkUIManager_Type
import gtk.Widget as PyGtkWidget_Type
import gtk.ActionGroup as PyGtkActionGroup_Type
import pygkeyfile.GKeyFile as PyGKeyFile_Type
%%
ignore-glob
  *_get_type
%%
body

QofBook *gnc_get_current_book();

static PyObject *
makePyObjectFromPrintf(const char *fmt, ...)
{
    PyObject *rv = NULL;
    char msg[2048];
    int slen = 0;
    va_list args;

    memset(msg, 0, sizeof(msg));
    va_start(args, fmt);
    slen = vsnprintf(msg, sizeof(msg), fmt, args);
    va_end(args);

    if (slen > 0)
        rv = PyString_FromStringAndSize(msg, slen);

    return rv;
}

%%
override gnc_plugin_page_recreate_page kwargs
// assuming python type self object here
// this ought to be a class method but dont see to do this
// making it a module level function currently
// note this is unlikely to ever be called from python
static PyObject *
_wrap_gnc_plugin_page_recreate_page(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "window", "page_type", "key_file", "page_group", NULL };
    PyObject *window_obj;
    GtkWidget *window;
    const gchar *page_type;
    PyObject *key_file_obj;
    GKeyFile *key_file = NULL;
    const gchar *page_group;
    GncPluginPage *pageret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OsOs:GncPluginPage.recreate_page",
                                     kwlist, &window_obj, &page_type, &key_file_obj, &page_group)) {
        return NULL;
    }

    if (pygobject_check(window_obj, &PyGtkWidget_Type))
        window = GTK_WIDGET(pygobject_get(window_obj));
    else if (window_obj != Py_None) {
        PyErr_SetString(PyExc_TypeError,
                        "window must be a GtkWidget or None");
        return NULL;
    }

    // just to make my life complicated we dont have an easy GKeyFile python binding!!
    // GKeyFile is not a GObject object either
    if (key_file_obj != Py_None)
        {
        if (! PyObject_TypeCheck(key_file_obj, &PyGKeyFile_Type)) {
            PyErr_SetString(PyExc_TypeError, "key_file must be a GKeyFile object");
            return NULL;
        }
        key_file = ((PyGKeyFile *) key_file_obj)->key_file;
        }
    else
        {
        PyErr_SetString(PyExc_TypeError, "key_file must not be None but a GKeyFile object");
        return NULL;
        }

    pageret = gnc_plugin_page_recreate_page(window, page_type, key_file, page_group);

    /* pygobject_new handles NULL checking */
    return pygobject_new((GObject *)pageret);
}

%%
override gnc_plugin_page_save_page kwargs
static PyObject *
_wrap_gnc_plugin_page_save_page(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "key_file", "group_name", NULL };
    PyObject *key_file_obj;
    GKeyFile *key_file = NULL;
    const gchar *group_name;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "Os:GncPluginPage.save_page",
                                     kwlist, &key_file_obj, &group_name)) {
        return NULL;
    }

    // just to make my life complicated we dont have an easy GKeyFile python binding!!
    // GKeyFile is not a GObject object either
    if (key_file_obj != Py_None)
        {
        if (! PyObject_TypeCheck(key_file_obj, &PyGKeyFile_Type)) {
            PyErr_SetString(PyExc_TypeError, "key_file must be a GKeyFile object");
            return NULL;
        }
        // whats a good way to access this??
        key_file = ((PyGKeyFile *) key_file_obj)->key_file;
        }
    else
        {
        PyErr_SetString(PyExc_TypeError, "key_file must not be None but a GKeyFile object");
        return NULL;
        }

    gnc_plugin_page_save_page(GNC_PLUGIN_PAGE(self->obj), key_file, group_name);

    Py_INCREF(Py_None);
    return Py_None;
}

%%
override gnc_plugin_page_add_book kwargs
static PyObject *
_wrap_gnc_plugin_page_add_book(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "book", NULL };
    PyObject *book_obj;
    QofBook *book;

    QofBook *curbok = gnc_get_current_book ();
    fprintf(stderr,"add_book book curr %llx\n",(unsigned long long)curbok);

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GncPluginPage.add_book",
                                     kwlist, &book_obj)) {
        //if (PyErr_Occurred())
        //    PyErr_Print();
        return NULL;
    }

    // how to deal with book 
    // for the moment allow either integer or PyCObject
    // what we really need is to allow for a gnucash python bindings Book object
    // this might require pulling in some more stuff though
    if (book_obj != Py_None)
        {
        if (PyInt_Check(book_obj)) {
            book = (QofBook *) PyInt_AsUnsignedLongLongMask(book_obj);
        } else if (PyLong_Check(book_obj)) {
            book = (QofBook *) PyLong_AsUnsignedLongLong(book_obj);
        } else if (PyCObject_Check(book_obj)) {
            book = (QofBook *) PyCObject_AsVoidPtr(book_obj);
        } else {
            PyErr_SetString(PyExc_TypeError, "book must be a book object");
            return NULL;
        }
        }
    else
        {
        PyErr_SetString(PyExc_TypeError, "book must be a book object");
        return NULL;
        }

    fprintf(stderr,"add_book book real %llx\n",(unsigned long long)book);

    gnc_plugin_page_add_book (GNC_PLUGIN_PAGE(self->obj), book);

    Py_INCREF(Py_None);
    return Py_None;
}


%%
override gnc_plugin_page_has_book kwargs
static PyObject *
_wrap_gnc_plugin_page_has_book(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "book", NULL };
    PyObject *book_obj;
    QofBook *book;
    gboolean hasret;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GncPluginPage.has_book",
                                     kwlist, &book_obj)) {
        return NULL;
    }

    // how to deal with book 
    // for the moment assuming passed as PyCObject - will worry about how to generate this later
    if (book_obj != Py_None)
        {
        if (PyInt_Check(book_obj)) {
            book = (QofBook *) PyInt_AsUnsignedLongLongMask(book_obj);
        } else if (PyLong_Check(book_obj)) {
            book = (QofBook *) PyLong_AsUnsignedLongLong(book_obj);
        } else if (PyCObject_Check(book_obj)) {
            book = (QofBook *) PyCObject_AsVoidPtr(book_obj);
        } else {
            PyErr_SetString(PyExc_TypeError, "book must be a book object");
            return NULL;
        }
        }
    else
        {
        PyErr_SetString(PyExc_TypeError, "book must be a book object");
        return NULL;
        }

    hasret = gnc_plugin_page_has_book (GNC_PLUGIN_PAGE(self->obj), book);

    if (hasret)
        {
        Py_INCREF(Py_True);
        return Py_True;
        }
    else
        {
        Py_INCREF(Py_False);
        return Py_False;
        }
}

%%
override gnc_plugin_page_access_private_data
static PyObject *
_wrap_gnc_plugin_page_access_private_data(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    PyObject *class_obj;

    GncPluginPage *page = (GncPluginPage *)self->obj;
    GncPluginPageClass *klass = GNC_PLUGIN_PAGE_GET_CLASS(page);

    fprintf(stderr,"access plugin class is %llx\n",(unsigned long long) klass);

    //klass->tab_icon    = NULL;
    //klass->plugin_name = NULL;

    /* pyg_pointer_new handles NULL checking */
    class_obj = pyg_pointer_new(G_TYPE_POINTER,klass);

    return class_obj;

}

%%
override gnc_plugin_page_set_class_init_data kwargs

//  the following are necesssary as I can see no way to set the private class data
//  of a C code GObject subtype in python - except by providing some access functions
// here I need to set the page_name without calling the set_page_name function

static PyObject *
_wrap_gnc_plugin_page_set_class_init_data(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "plugin_name", "tab_icon", NULL };
    PyObject *plugin_name_obj = NULL;
    PyObject *tab_icon_obj = NULL;

    GncPluginPage *page = (GncPluginPage *)self->obj;
    GncPluginPageClass *klass = GNC_PLUGIN_PAGE_GET_CLASS(page);

    // hmm - for me looks like do NOT use GIL state in functions called from python!!

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O|O:GncPluginPage.set_class_init_data",
                                     kwlist, &plugin_name_obj, &tab_icon_obj)) {
        return NULL;
    }

    char *pname = PyString_AsString(plugin_name_obj);

    //klass->tab_icon    = NULL;
    klass->plugin_name = pname;

    Py_INCREF(Py_None);
    return Py_None;
}

%%
override gnc_plugin_page_set_callbacks kwargs

GtkWidget *
gnc_plugin_page_generic_create_widget(GncPluginPage *plugin_page);
void
gnc_plugin_page_generic_destroy_widget(GncPluginPage *plugin_page);
void
gnc_plugin_page_generic_save_page(GncPluginPage *page, GKeyFile *file, const gchar *group);
void
gnc_plugin_page_generic_window_changed(GncPluginPage *plugin_page, GtkWidget *window);
void
gnc_plugin_page_generic_page_name_changed(GncPluginPage *plugin_page, const gchar *name);
void
gnc_plugin_page_generic_page_update_edit_menu_actions(GncPluginPage *plugin_page, gboolean hide);
gboolean
gnc_plugin_page_generic_page_finish_pending(GncPluginPage *plugin_page);

GncPluginPage *
gnc_plugin_page_generic_recreate_page(GtkWidget *window, GKeyFile *file, const gchar *group);


static PyObject *
_wrap_gnc_plugin_page_set_callbacks(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    //static char *kwlist[] = { "callbacks", NULL };
    PyObject *callb_obj = NULL;

    GncPluginPage *page = (GncPluginPage *)self->obj;
    GncPluginPageClass *gnc_plugin_page_class = GNC_PLUGIN_PAGE_GET_CLASS(page);

    // hmm - for me looks like do NOT use GIL state in functions called from python!!

    //if (!PyArg_ParseTupleAndKeywords(args, kwargs, "O:GncPluginPage.set_callbacks",
    //                                 kwlist, &callb_obj)) {
    //    return NULL;
    //}

    fprintf(stderr,"callback plugin class is %llx\n",(unsigned long long) gnc_plugin_page_class);

    //klass->tab_icon    = NULL;
    //klass->plugin_name = NULL;

    // I think these will be null if not defined - which looks like is tested for in superclass
    // yes - this is defined in gnc-plugin-page.c

    // looks like we need them all defined - make it so

    if (!PyObject_HasAttrString((PyObject*)self,"create_widget")) {
        fprintf(stderr,"no create_widget callback!!\n");
        PyErr_SetString(PyExc_KeyError, "no create_widget callback");
        return NULL;
    }
    if (!PyObject_HasAttrString((PyObject*)self,"destroy_widget")) {
        fprintf(stderr,"no destroy_widget callback!!\n");
        PyErr_SetString(PyExc_KeyError, "no destroy_widget callback");
        return NULL;
    }
    if (!PyObject_HasAttrString((PyObject*)self,"save_page")) {
        fprintf(stderr,"no save_page callback!!\n");
        PyErr_SetString(PyExc_KeyError, "no save_page callback");
        return NULL;
    }
    //if (!PyObject_HasAttrString((PyObject*)self,"window_changed")) {
    //    fprintf(stderr,"no window_changed callback!!\n");
    //    PyErr_SetString(PyExc_KeyError, "no window_changed callback");
    //    return NULL;
    //}
    if (!PyObject_HasAttrString((PyObject*)self,"page_name_changed")) {
        fprintf(stderr,"no page_name_changed callback!!\n");
        PyErr_SetString(PyExc_KeyError, "no page_name_changed callback");
        return NULL;
    }
    if (!PyObject_HasAttrString((PyObject*)self,"update_edit_menu_actions")) {
        fprintf(stderr,"no update_edit_menu_actions callback!!\n");
        PyErr_SetString(PyExc_KeyError, "no update_edit_menu_actions callback");
        return NULL;
    }
    if (!PyObject_HasAttrString((PyObject*)self,"finish_pending")) {
        fprintf(stderr,"no finish_pending callback!!\n");
        PyErr_SetString(PyExc_KeyError, "no finish_pending callback");
        return NULL;
    }

    // these are instance callbacks -  in that the first argument is an instance pointer
    // bit confusing as they are effectively defined in the class
    // so might think they are class methods in python
    // Im still confused - is there only one instance of the class structure in GType system
    // I think there is - and I think it is defined once the type is registered
    gnc_plugin_page_class->finish_pending   = gnc_plugin_page_generic_page_finish_pending;
    gnc_plugin_page_class->create_widget   = gnc_plugin_page_generic_create_widget;
    gnc_plugin_page_class->destroy_widget  = gnc_plugin_page_generic_destroy_widget;
    gnc_plugin_page_class->save_page       = gnc_plugin_page_generic_save_page;
    //gnc_plugin_page_class->window_changed   = gnc_plugin_page_generic_window_changed;
    gnc_plugin_page_class->page_name_changed = gnc_plugin_page_generic_page_name_changed;
    gnc_plugin_page_class->update_edit_menu_actions = gnc_plugin_page_generic_page_update_edit_menu_actions;


    fprintf(stderr,"callback plugin class end\n");

    Py_INCREF(Py_None);
    return Py_None;
}

    /** Function called to create the display widget for a
     *  particular type of plugin.  The returned widget should
     *  encompass all information that goes with this page,
     *  including scroll bars, a summary bar, etc.
     *
     *  @param plugin_page A pointer to the plugin for which a
     *  display widget should be created.
     *
     *  @return A displayable gtk widget. */
GtkWidget *
gnc_plugin_page_generic_create_widget(GncPluginPage *plugin_page)
{
    PyGILState_STATE gstate;
    PyObject *PyRet;
    GtkWidget *widget = NULL;

    fprintf(stderr,"C create widget call\n");

    GQuark quark;
    PyObject *pyobj;

    // this works beautifully!!
    // we get the python object from the GObject
    quark = g_quark_from_string("PyGObject::wrapper");
    pyobj = g_object_get_qdata((GObject *)plugin_page, quark);

    fprintf(stderr,"quark wrapper is %llx\n",(void *)pyobj);

    gstate = PyGILState_Ensure();

    if (PyObject_HasAttrString(pyobj,"create_widget"))
        fprintf(stderr,"pyobj has attr\n");
    else
        fprintf(stderr,"pyobj does not have attr\n");

    PyRet = PyObject_CallMethodObjArgs(pyobj,PyString_FromString("create_widget"),NULL);
    if (PyErr_Occurred())
        {
        fprintf(stderr,"Python Error in create_widget\n");
        PyErr_Print();
        PyGILState_Release(gstate);
        // what we might do is construct a minimal GtkWidget and return that
        // NULL gives bad things
        return NULL;
        }

    // need to figure how to get widget from this
    // ah - this this might work
    // may need to extract underlying GObject object
    widget = (GtkWidget *)PyObject_Hash(PyRet);

    PyGILState_Release(gstate);

    return widget;
}

    /** Function called to destroy the display widget for a
     *  particular type of plugin.
     *
     *  @param plugin_page A pointer to the plugin whose display
     *  widget should be destroyed. */
void
gnc_plugin_page_generic_destroy_widget(GncPluginPage *plugin_page)
{
    PyGILState_STATE gstate;

    GQuark quark;
    PyObject *pyobj;

    // this works beautifully!!
    // we get the python object from the GObject
    quark = g_quark_from_string("PyGObject::wrapper");
    pyobj = g_object_get_qdata((GObject *)plugin_page, quark);

    gstate = PyGILState_Ensure();
    PyObject_CallMethodObjArgs(pyobj,PyString_FromString("destroy_widget"),NULL);
    if (PyErr_Occurred())
        {
        fprintf(stderr,"Python Error in destroy_widget\n");
        PyErr_Print();
        }
    PyGILState_Release(gstate);
}

    /** Save enough information about this page so that it can be
     *  recreated next time the user starts gnucash.
     *
     *  @param page The page to save.
     *
     *  @param key_file A pointer to the GKeyFile data structure where the
     *  page information should be written.
     *
     *  @param group_name The group name to use when writing data.
     *  The name is specific to this page instance. */

void
gnc_plugin_page_generic_save_page(GncPluginPage *page, GKeyFile *file, const gchar *group)
{
    PyGILState_STATE gstate;

    GQuark quark;
    PyObject *pyobj;

    // this works beautifully!!
    // we get the python object from the GObject
    quark = g_quark_from_string("PyGObject::wrapper");
    pyobj = g_object_get_qdata((GObject *)page, quark);

    if (pyobj == NULL)
        {
        fprintf(stderr,"Error in save_page - no Python wrapper found\n");
        }
    else
        {
        gstate = PyGILState_Ensure();

        PyObject *pygkeyfile = (PyObject *)PyObject_New(PyGKeyFile,&PyGKeyFile_Type);
        ((PyGKeyFile *)pygkeyfile)->key_file = file;

        PyObject *pygroup = PyString_FromString(group);

        PyObject_CallMethodObjArgs(pyobj,PyString_FromString("save_page"),pygkeyfile,pygroup,NULL);
        if (PyErr_Occurred())
            {
            fprintf(stderr,"Python Error in save_page\n");
            PyErr_Print();
            }
        PyGILState_Release(gstate);
        }
}

    /** Create a new page based on the information saved during a
     *  previous instantiation of gnucash.  This function may or
     *  may not install the new page in the window as it sees fit.
     *  Generally the function will install the page int the
     *  window in order to manipulate the menu items that are
     *  created at install time.
     *
     *  @param window The window where this new page will be
     *  installed.
     *
     *  @param key_file A pointer to the GKeyFile data structure where the
     *  page information should be retrieved.
     *
     *  @param group_name The group name to use when retrieving
     *  data.  The name is specific to this page instance.
     *
     *  @return A pointer to the new page. */

GncPluginPage *
gnc_plugin_page_generic_recreate_page(GtkWidget *window, GKeyFile *file, const gchar *group)
{
    PyGILState_STATE gstate;
    PyObject *PyRet = Py_None;
    GncPluginPage *page = NULL;
    gchar *page_type = NULL;
    GError *error = NULL;

    gstate = PyGILState_Ensure();

    // although when this function was called gnucash knew what type called it
    // at this point we have no idea what GType called this
    // we can redo how gnucash figured the type here

    page_type = g_key_file_get_string(file, group, "PageType", &error);

    if (error != NULL) {
        // this really is impossible
        fprintf(stderr,"gnc_plugin_page_generic_recreate_page: Impossible - cannot find GType\n");
        PyGILState_Release(gstate);
        return NULL;
    }

    fprintf(stderr,"generic recreate page type is %s\n",page_type);

    // we still have a problem - how to map from the GType back to python
    // we know how to get from object instance - can we do for class??
    // looks like we can if we subclassed a GType in python
    GType gtype = g_type_from_name(page_type);
    GQuark quark = g_quark_from_string("PyGObject::class");
    PyObject *py_class = g_type_get_qdata(gtype, quark);

    fprintf(stderr,"quark wrapper is %llx\n",(void *)py_class);

    PyObject *pywindow = pygobject_new((GObject*)window);

    PyObject *pygkeyfile = (PyObject *)PyObject_New(PyGKeyFile,&PyGKeyFile_Type);
    ((PyGKeyFile *)pygkeyfile)->key_file = file;

    PyObject *pygroup = PyString_FromString(group);

    PyRet = PyObject_CallMethodObjArgs(py_class,PyString_FromString("recreate_page"),pywindow,pygkeyfile,pygroup,NULL);
    if (PyErr_Occurred())
        {
        fprintf(stderr,"gnc_plugin_page_generic_recreate_page: Python Error\n");
        PyErr_Print();
        PyGILState_Release(gstate);
        return NULL;
        }

    if (PyRet == Py_None) {
        PyGILState_Release(gstate);
        return NULL;
    }

    // need to figure how to get widget from this
    // ah - this this might work
    // may need to extract underlying GObject object
    page = (GncPluginPage *)PyObject_Hash(PyRet);

    fprintf(stderr,"page is %llx\n",(void *)page);

    PyGILState_Release(gstate);

    return page;
    
}

    /** Perform plugin specific actions when a page is added to a
     *  window (or has been removed from one window and added to a
     *  new window).  This function is called after the page is
     *  installed in the window, just before the window's
     *  PAGE_ADDED signal is generated.
     *
     *  @param page The page that was added to a window.
     *
     *  @param window The window where the page was added. */
void
gnc_plugin_page_generic_window_changed(GncPluginPage *plugin_page, GtkWidget *window)
{
    PyGILState_STATE gstate;
    GQuark quark;
    PyObject *pyobj;

    // this works beautifully!!
    // we get the python object from the GObject
    quark = g_quark_from_string("PyGObject::wrapper");
    pyobj = g_object_get_qdata((GObject *)plugin_page, quark);

    gstate = PyGILState_Ensure();

    PyObject *pywindow = pygobject_new((GObject*)window);

    PyObject_CallMethodObjArgs(pyobj,PyString_FromString("window_changed"),pywindow,NULL);
    if (PyErr_Occurred())
        {
        fprintf(stderr,"Python Error in window_changed\n");
        PyErr_Print();
        }

    PyGILState_Release(gstate);
}

    /** This function vector allows page specific actions to occur
     *  when the page name is changed.
     *
     *  @param page The page to update.
     *
     *  @param name The new name for this page. */
void
gnc_plugin_page_generic_page_name_changed(GncPluginPage *plugin_page, const gchar *name)
{
    PyGILState_STATE gstate;
    GQuark quark;
    PyObject *pyobj;

    // this works beautifully!!
    // we get the python object from the GObject
    quark = g_quark_from_string("PyGObject::wrapper");
    pyobj = g_object_get_qdata((GObject *)plugin_page, quark);

    gstate = PyGILState_Ensure();

    PyObject *pyname = PyString_FromString(name);

    PyObject_CallMethodObjArgs(pyobj,PyString_FromString("page_name_changed"),pyname,NULL);
    if (PyErr_Occurred())
        {
        fprintf(stderr,"Python Error in save_page\n");
        PyErr_Print();
        }

    PyGILState_Release(gstate);
}

    /** This function vector allows page specific actions to
     *  override the generic code for setting the sensitivity of
     *  items in the Edit menu.
     *
     *  @param page The front page in a main window..
     *
     *  @param hide Whether the widgets should be shown or
     *  hidden. */
void
gnc_plugin_page_generic_page_update_edit_menu_actions(GncPluginPage *plugin_page, gboolean hide)
{
    PyGILState_STATE gstate;
    GQuark quark;
    PyObject *pyobj;

    // this works beautifully!!
    // we get the python object from the GObject
    quark = g_quark_from_string("PyGObject::wrapper");
    pyobj = g_object_get_qdata((GObject *)plugin_page, quark);

    gstate = PyGILState_Ensure();

    PyObject *pybool = PyBool_FromLong(hide);

    PyObject_CallMethodObjArgs(pyobj,PyString_FromString("update_edit_menu_actions"),pybool,NULL);
    if (PyErr_Occurred())
        {
        fprintf(stderr,"Python Error in update_edit_menu_actions\n");
        PyErr_Print();
        }

    PyGILState_Release(gstate);
}

    /** This function vector is called to finish any outstanding
     *  activities.  It will be called for such things as closing a
     *  page, saving the data file, etc.
     *
     *  @param page The page in a main window.
     *
     *  @return FALSE if the page could not or would not comply,
     *  which should cancel the pending operation.  TRUE
     *  otherwise */
gboolean
gnc_plugin_page_generic_page_finish_pending(GncPluginPage *plugin_page)
{
    PyGILState_STATE gstate;
    PyObject *PyRet = Py_None;
    GQuark quark;
    PyObject *pyobj;

    // this works beautifully!!
    // we get the python object from the GObject
    quark = g_quark_from_string("PyGObject::wrapper");
    pyobj = g_object_get_qdata((GObject *)plugin_page, quark);

    gstate = PyGILState_Ensure();
    PyRet = PyObject_CallMethodObjArgs(pyobj,PyString_FromString("finish_pending"),NULL);
    if (PyErr_Occurred())
        {
        fprintf(stderr,"Python Error in finish_pending\n");
        PyErr_Print();
        }
    PyGILState_Release(gstate);
    
    if (PyRet == Py_True)
        return 1;
    else
        return 0;
}

%%
override gnc_plugin_page_set_callback kwargs

// new attempt at setting callbacks
// all available callbacks defined as keywords
// but value of keyword is immaterial as only self object is used ie only presence of keyword is significant
// essentially this allows for some callbacks to be not used
// not sure if this helps

static PyObject *
_wrap_gnc_plugin_page_set_callback(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "create_widget", NULL };
    PyObject *create_widget_obj = NULL;

    GncPluginPage *page = (GncPluginPage *)self->obj;
    GncPluginPageClass *gnc_plugin_page_class = GNC_PLUGIN_PAGE_GET_CLASS(page);

    // hmm - for me looks like do NOT use GIL state in functions called from python!!

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|O:GncPluginPage.set_callback",
                                     kwlist, &create_widget_obj)) {
        return NULL;
    }

    fprintf(stderr,"callback plugin class is %llx\n",(unsigned long long) gnc_plugin_page_class);

    //klass->tab_icon    = NULL;
    //klass->plugin_name = NULL;

    if (create_widget_obj != NULL) {
        if (!PyObject_HasAttrString((PyObject*)self,"create_widget")) {
            fprintf(stderr,"no create_widget callback!!\n");
            PyErr_SetString(PyExc_KeyError, "no create_widget callback");
            return NULL;
        }
        gnc_plugin_page_class->create_widget   = gnc_plugin_page_generic_create_widget;
    }

    Py_INCREF(Py_None);
    return Py_None;
}

%%
override gnc_plugin_page_set_recreate_callback kwargs


static PyObject *
_wrap_gnc_plugin_page_set_recreate_callback(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "page_type", NULL };
    char *gtype_name = NULL;

    // allow to pass in the GType name

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "s:GncPluginPage.set_recreate_callback",
                                     kwlist, &gtype_name)) {
        return NULL;
    }

    fprintf(stderr,"set_recreate type %s\n",gtype_name);

    // this is a creation callback
    // once the GType has been registered we call this to setup the recreate_page callback

    // OK - so we need access to the plugin page class structure - how to get to it
    // this is the function we need to run

    // evidence is this should return a pointer to the class structure
    GType gtype = g_type_from_name(gtype_name);
    if (gtype == 0) {
        //PyObject *errStr = makePyObjectFromPrintf("%s GType is not defined", gtype_name);
        //PyErr_SetObject(PyExc_TypeError, errStr);
        PyErr_SetString(PyExc_TypeError, "GType is not defined");
        return NULL;
    }
    // get the GncPluginPagePythonReport class structure but re-type it as the
    // parent GncPluginPage structure - the parent structure is always first
    GncPluginPageClass *gnc_plugin_page_sub_class = g_type_class_peek(gtype);
    if (gnc_plugin_page_sub_class == NULL) {
        //PyObject *errStr = makePyObjectFromPrintf("%s class is NULL", gtype_name);
        //PyErr_SetObject(PyExc_TypeError, errStr);
        PyErr_SetString(PyExc_TypeError, "GType class is NULL");
        return NULL;
    }
    fprintf(stderr,"set_recreate class 1 %llx\n",(unsigned long long)gnc_plugin_page_sub_class);

    //GncPluginPageClass *gnc_plugin_page_class = g_type_class_peek_parent(gnc_plugin_page_sub_class);
    //if (gnc_plugin_page_class == NULL) {
    //    PyErr_SetString(PyExc_TypeError, "GncPluginPage class is NULL");
    //    return NULL;
    //}
    //fprintf(stderr,"set_recreate class 2 %llx\n",(unsigned long long)gnc_plugin_page_class);

    // OK so the two above class pointers are different - we need the GncPluginPage structure
    // that is part of the GncPluginPagePythonReport type 
    // unfortunately because this is a "class" method there is no page pointer in the argument
    // list so we really need a different function name of this callback for each class
    // although ctypes can do this not figured out how to apply this here
    gnc_plugin_page_sub_class->recreate_page   = gnc_plugin_page_generic_recreate_page;

    Py_INCREF(Py_None);
    return Py_None;
}

%%
override gnc_plugin_init_short_names kwargs

static PyObject *
_wrap_gnc_plugin_init_short_names(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "action_group", "toolbar_labels", NULL };
    PyObject *action_group_obj;
    GtkActionGroup *action_group;
    PyObject *toolbar_labels_obj;
    action_toolbar_labels *toolbar_labels;
    int indx_toolbar_labels;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OO:GncPluginPage.init_short_names",
                                     kwlist, &action_group_obj, &toolbar_labels_obj)) {
        return NULL;
    }

    if (pygobject_check(action_group_obj, &PyGtkActionGroup_Type)) {
        action_group = GTK_ACTION_GROUP(pygobject_get(action_group_obj));
    } else {
        PyErr_SetString(PyExc_TypeError,
                        "action_group must be a GtkActionGroup");
        return NULL;
    }

    if (!PyList_Check(toolbar_labels_obj)) {
        PyErr_SetString(PyExc_TypeError, "toolbar_labels argument is not a list");
        return NULL;
    }
    int nitms = PyList_Size(toolbar_labels_obj);
    toolbar_labels = (action_toolbar_labels *) g_malloc(sizeof(action_toolbar_labels)*(nitms+1));
    for (indx_toolbar_labels=0; indx_toolbar_labels<nitms; indx_toolbar_labels++)
        {
        PyObject *ptupl = PyList_GetItem(toolbar_labels_obj,indx_toolbar_labels);
        if (!PyTuple_Check(ptupl)) {
            PyErr_SetString(PyExc_TypeError, "toolbar_labels list item is not a tuple");
            return NULL;
        }
        PyObject *pitm1 = PyTuple_GetItem(ptupl,0);
        if (!PyString_Check(pitm1)) {
            PyErr_SetString(PyExc_TypeError, "toolbar_labels list item action_name is not a string");
            return NULL;
        }
        PyObject *pitm2 = PyTuple_GetItem(ptupl,1);
        if (!PyString_Check(pitm2)) {
            PyErr_SetString(PyExc_TypeError, "toolbar_labels list item label is not a string");
            return NULL;
        }
        toolbar_labels[indx_toolbar_labels].action_name = PyString_AsString(pitm1);
        toolbar_labels[indx_toolbar_labels].label = PyString_AsString(pitm2);
        }
    toolbar_labels[nitms].action_name = NULL;
    toolbar_labels[nitms].label = NULL;

    // hmm - this does not check if the action names in toolbar_labels
    // actually exists in the action_group
    gnc_plugin_init_short_names (action_group, toolbar_labels);

    // Im assuming gnc_plugin_init_short_names takes a copy of the names
    g_free(toolbar_labels);
    
    Py_INCREF(Py_None);
    return Py_None;
}

%%
override gnc_plugin_update_actions kwargs

static PyObject *
_wrap_gnc_plugin_update_actions(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "action_group", "action_names", "property_name", "value", NULL };
    PyObject *action_group_obj;
    GtkActionGroup *action_group;
    PyObject *action_names_obj;
    const gchar **action_names = NULL;
    gchar *property_name = NULL;
    PyObject *py_value;
    int value;
    int indx_action_names;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "OOsi:GncPluginPage.update_actions",
                                     kwlist, &action_group_obj, &action_names_obj, &property_name, &value)) {
        return NULL;
    }

    if (pygobject_check(action_group_obj, &PyGtkActionGroup_Type)) {
        action_group = GTK_ACTION_GROUP(pygobject_get(action_group_obj));
    } else {
        PyErr_SetString(PyExc_TypeError,
                        "action_group must be a GtkActionGroup");
        return NULL;
    }

    if (!PyList_Check(action_names_obj)) {
        PyErr_SetString(PyExc_TypeError, "action_names argument is not a list");
        return NULL;
    }
    int nitms = PyList_Size(action_names_obj);
    action_names = (const gchar **) g_malloc(sizeof(gchar*)*(nitms+1));
    for (indx_action_names=0; indx_action_names<nitms; indx_action_names++)
        {
        PyObject *pstr = PyList_GetItem(action_names_obj,indx_action_names);
        if (!PyString_Check(pstr)) {
            PyErr_SetString(PyExc_TypeError, "action_names list item is not a string");
            return NULL;
        }
        action_names[indx_action_names] = PyString_AsString(pstr);
        }
    action_names[nitms] = NULL;

    //if (!PyString_Check(property_name_obj)) {
    //    PyErr_SetString(PyExc_TypeError, "property_name is not a string");
    //    return NULL;
    //}
    //property_name = PyString_AsString(property_name_obj);

    //if (PyInt_Check(py_value)) {
    //    value = PyInt_AsLong(py_value);
    //}

    // hmm - this does not check if the action names actually exists in the action_group
    gnc_plugin_update_actions (action_group, action_names, property_name, value);

    // Im assuming gnc_plugin_init_short_names takes a copy of the names
    g_free(action_names);

    Py_INCREF(Py_None);
    return Py_None;
}

